---- Part 1 ----

-- This function creates a line of stars
star_line :: Int -> String 
star_line x
  | x > 0    = "*" ++ star_line (x-1)
  | otherwise   = "" 

-- This function creates a box by making x star lines seperated by a new line
-- Outputs empty string if the width = 0 or when the correct number of rows have been generated
box :: Int -> Int -> String
box x y 
  | x <= -1 || y <= 0          = ""
  | x == 0                    =  ""
  | otherwise                 = ((star_line y) ++ "\n") ++ box (x - 1) y

-- This function creates stairs by creating z many boxes with length (y + the inital y) as z decrements until reaching 0
steps_2 :: Int -> Int -> Int -> Int -> String
steps_2 x y z i 
  | z <= 0 || x <= -1 || y <= 0    = ""
  | z == 0                         = box x y
  | otherwise                      = (box x y) ++ steps_2 x (y+i) (z-1) i

-- This function runs the steps function however allows i to be the inital y number
-- This allows the inital number to be added onto the current y everytime z decrements
steps :: Int -> Int -> Int -> String
steps x y z = steps_2 x y z y

---- Part 2 ----

--Function which makes a gap of x amount
gap :: Int -> String
gap x = replicate x ' '

--Function which makes a line of starts of x amount
line :: Int -> String
line x = replicate x '*'

{-|Function finishes when y = ((x-2) `div` 2) as x is the no. rows. This function handles the parts discluding 
the top and bottom lines, and the identicle but flipped part generated by the function cross_2. This means it should only run that many times

The outer gap will start at 0, and increment by 1 everytime. This means the middle gap's size is determined by 
(x-4)-(2*y) where the -4 comes from the 4 stars and the -(2*y) comes from the fact that y the gap size so as there above 2 identicle y gap sizes, one on each side, we *2

The function should stop running when that middle gap is less than 0. 
-}
cross :: Int -> Int-> String
cross x y
  | x < 5                 = ""
  | midGap < 0           = ""
  | otherwise             = ("*" ++ gap y ++ "*" ++ gap midGap ++ "*" ++ gap y ++ "*\n") ++ cross x (y+1)
  where midGap = (x-4)-(2*y)
        finish = ((x-2) `div` 2) 

--This function is very similar to the function above other than the fact that the outer gaps are reduced each time, as the middle one increases. The function ends when y, the gaps on the end, < 0.  
cross_2 :: Int -> Int -> String
cross_2 x y
  | x < 5        = ""
  | y < 0       = ""
  | otherwise    = ("*" ++ gap y ++ "*" ++ gap midGap ++ "*" ++ gap y ++ "*\n") ++ cross_2 x (y-1)
  where midGap = (x-4)-(2*y)

--This function treats even and odd inputs slightly differently.
--For even inputs, only the top and bottom lines need to be added as there will be a 2x2 box in the middle.
--For the odd inputs, a new line inbetween the M and W must be made. 
--The gaps are determined by the ((x-3) `div` 2). The -3 comes from the 3 stars, and the div 2 as there are 2 sides to consider
--The outer gap start point which is used for cross_2 is determined by ((x-4) `div` 2). -4 for the N. starts, and div 2 as there are 2 sides of gaps
flagpattern :: Int -> String
flagpattern x 
  | x < 5    = ""
  | even x   = line x ++ "\n" ++ (cross x 0) ++ (cross_2 x outer_gap_start) ++ line x ++ "\n"
  | odd x    = line x ++ "\n" ++ (cross x 0) ++ ("*" ++ gap mid_outer_gap ++ "*" ++ gap mid_outer_gap ++ "*" ++ "\n")  ++ (cross_2 x outer_gap_start ) ++ line x ++ "\n"
  where mid_outer_gap = ((x-3) `div` 2)
        outer_gap_start = ((x-4) `div` 2)

---- Part 3 ----
 
--This function will output a string where all concurrent chars not seperated by strings can be considered words
--The first guard determines the stop point if a matching char is found
--The second guard is for when a macthing char isnt found but the string is a length of 1, we want it to end
--The third guard is for if a matching char is found, it will be added to the prexisting string
--The fourth guard is key. This is when there is not a match but there is still more chars to be checked. The space is crutial as in the future, a list of strings will be made by taking each char(s) between gaps. "  d word sfg" -> ["d", "word", "sfg"]
--There shouldn't be an otherwise, but just in case, we output ""
isIn :: String -> String -> String
isIn (x:xs) find
  | length (xs) == 0 && x `elem` find  = x : []
  | length (xs) == 0                   = ""
  | x `elem` find                       = x : isIn xs find
  | x `notElem` find                  = ' ' : isIn xs find
  | otherwise                          = ""

--'find' is the substring we are looking for in the string 'looking' and 'swap' is what we want to replace 'find' with
-- 'i' is how many chars are being searched which havent been checked yet, and is reset to 1 after a 'find' is found
-- The first guard will come true when there is no longer any 'find' in what is left of looking, so the rest of the inital string is added onto the already changed part of the string
--In the second guard, we run (take i looking) which will take i many characters in the string looking. We run that through as a parameter alongside 'find' and then run 'words' on it to get the list of strings mentioned previously
--if 'find' is within this, there is a substring needed to be changed in looking. This is why we take chars before 'find' was found, and add them onto the new word. This removes 'find' and adds 'swap' instead
-- it then will re-run the function with a reduced 'looking', not including any previous chars, and a reset value i. 
--The otherwise will run if there is not a 'find' in the string, but looking hasn't been fully checked. The value of i is simply incremented by 1
replace :: String -> String -> String -> String -> Int -> String
replace initial looking find swap i
  | i == length(looking) + 1        = "" ++ looking 
  | find `elem` words (isIn (take i looking) find)  = ((take (i - length(find)) looking) ++ swap) ++ replace initial (drop i looking) find swap 1
  | otherwise                                  = replace initial looking find swap (i+1)

--This function simply formats everything correctly. i will always be 0
swapwords :: String -> String -> String -> String 
swapwords x y z = replace z z x y 1

---- Part 4 ----

matching_chars :: String -> String -> String --Returns a string of all the reaccuring chars
matching_chars x y = filter (/=' ') [t | t<-x, t `elem` y] 

 --Swaps the matching chars with *s
 --The case for which xs==[] checks if there is a match of chars between the last char in the first one and any one in the second on if and only if there hasn't been a max amount of crosses out reached already.
 --The guards just check for if a char in the first is in the second string
star_string :: String -> String -> Int -> String
star_string (x:[]) match i  = if x `elem` match && i /= length (match) then '*' : [] else x : []
star_string (x:xs) match i
  | i == length (match)        = x : star_string xs match i
  | x `elem` match             = '*' : star_string xs match (i+1)
  | otherwise                  = x : star_string xs match i

--This function will remove any stars and spaces as they will not be useful anymore
filter_stars :: String -> String -> String 
filter_stars x match = filter (/=' ') (filter (/='*') (star_string x match 0))

--An output of between 0 and 4 will determine the feelings of person 1 to person 2 and vise versa
opinion :: String -> Int 
opinion x = length(x) `mod` 4

--Depending on the num inputed, a certain string will be outputed
opinion_string :: Int -> String
opinion_string x
  | x == 1    = " loves "
  | x == 2    = " is physical with "
  | x == 3    = " hates "
  | x == 0    = " is indifferent to "
  | otherwise = " This shouldn't be possible "

--This function just runs all of that and puts it into the correct format
compatibility :: String -> String -> String
compatibility x y = x ++ opinion_string(opinion(filter_stars x (matching_chars x y))) ++ y ++ " and " ++ y ++ opinion_string(opinion(filter_stars y (matching_chars x y))) ++ x

---- Part 5 ----
--This function will take all the elements before y and form a list out of them
-- It does this by checking the first element of the list and adding that to a list as long as it is not equal to y, the splitter
take_till :: Eq a => [a] -> a -> [a]
take_till x y  
  | x == []        = []
  | head x == y    = []
  | otherwise      = (head x) : (take_till (tail x) y) 
   
--This has a strange name as it is essentially the split function.
--It works for if the string ends in the splitter a however if not, it crashes. 
--It will add lists together to form a list of lists. The drop removes all previous elements already within a list from the next computation. 
foo :: Eq b => [b] -> b -> [[b]]
foo x sep
  | x == []    = []
  | otherwise = (take_till x sep) : (foo (drop y x) sep) 
  where y = (length (take_till x sep) + 1)

--The filter removes any unnecessary empty lists
split :: Eq a => [a] -> a -> [[a]]
split [] sep = []
split x sep  = filter (not . null) (foo x sep) 